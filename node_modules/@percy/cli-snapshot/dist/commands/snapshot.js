"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Snapshot = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _config = _interopRequireDefault(require("@percy/config"));

var _cliCommand = _interopRequireWildcard(require("@percy/cli-command"));

var _core = _interopRequireDefault(require("@percy/core"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _globby = _interopRequireDefault(require("globby"));

var _yaml = _interopRequireDefault(require("yaml"));

var _config2 = require("../config");

var _utils = require("../utils");

var _package = _interopRequireDefault(require("../../package.json"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Snapshot extends _cliCommand.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "log", (0, _logger.default)('cli:snapshot'));
  }

  async run() {
    if (!this.isPercyEnabled()) {
      return this.log.info('Percy is disabled. Skipping snapshots');
    }

    let {
      pathname
    } = this.args;

    if (!_fs.default.existsSync(pathname)) {
      this.error(`Not found: ${pathname}`);
    }

    this.percy = new _core.default({ ...this.percyrc(),
      clientInfo: `${_package.default.name}/${_package.default.version}`,
      server: false
    });
    let pages = _fs.default.lstatSync(pathname).isDirectory() ? await this.loadStaticPages(pathname) : await this.loadPagesFile(pathname);
    let l = pages.length;
    if (!l) this.error('No snapshots found');
    let dry = this.flags['dry-run'];
    if (!dry) await this.percy.start();else this.log.info(`Found ${l} snapshot${l === 1 ? '' : 's'}`);

    for (let page of pages) {
      if (dry) {
        this.log.info(`Snapshot found: ${page.name}`);
        this.log.debug(`-> url: ${page.url}`);

        for (let s of page.additionalSnapshots || []) {
          let name = s.name || `${s.prefix || ''}${page.name}${s.suffix || ''}`;
          this.log.info(`Snapshot found: ${name}`);
          this.log.debug(`-> url: ${page.url}`);
        }
      } else {
        this.percy.snapshot(page);
      }
    }
  } // Called on error, interupt, or after running


  async finally(error) {
    var _this$percy, _this$server;

    await ((_this$percy = this.percy) === null || _this$percy === void 0 ? void 0 : _this$percy.stop(!!error));
    await ((_this$server = this.server) === null || _this$server === void 0 ? void 0 : _this$server.close());
  } // Starts a static server and returns a list of pages to snapshot.


  async loadStaticPages(pathname) {
    let config = this.percy.config.static;
    let baseUrl = this.flags['base-url'] || config.baseUrl;
    let dry = this.flags['dry-run'];

    if (baseUrl && !baseUrl.startsWith('/')) {
      this.error('The base-url must begin with a forward slash (/) ' + 'when snapshotting static directories');
    }

    this.server = await (0, _utils.serve)(pathname, { ...config,
      baseUrl,
      dry
    });
    let {
      host,
      rewrites
    } = this.server;
    let ignore = [].concat(config.ignore || []);
    let paths = await (0, _globby.default)(config.files, {
      cwd: pathname,
      ignore
    });
    return (0, _utils.mapPages)(paths, { ...config,
      host,
      rewrites
    });
  } // Loads pages to snapshot from a js, json, or yaml file.


  async loadPagesFile(pathname) {
    let ext = _path.default.extname(pathname);

    let baseUrl = this.flags['base-url'];
    let pages = [];

    if (baseUrl && !baseUrl.startsWith('http')) {
      this.error('The base-url must include a protocol and hostname ' + 'when snapshotting a list of pages');
    }

    if (ext === '.js') {
      pages = require(_path.default.resolve(pathname));
      if (typeof pages === 'function') pages = await pages();
    } else if (ext === '.json') {
      pages = JSON.parse(_fs.default.readFileSync(pathname, {
        encoding: 'utf-8'
      }));
    } else if (ext.match(/\.ya?ml$/)) {
      pages = _yaml.default.parse(_fs.default.readFileSync(pathname, {
        encoding: 'utf-8'
      }));
    } else {
      this.error(`Unsupported filetype: ${pathname}`);
    } // validate page listings


    let errors = _config.default.validate(pages, '/snapshot/list');

    if (errors) {
      this.log.warn('Invalid snapshot options:');

      for (let e of errors) this.log.warn(`- ${e.path}: ${e.message}`);
    } // support snapshots option for yaml references and lists of urls


    return (Array.isArray(pages) ? pages : pages.snapshots || []).map(page => (0, _utils.withDefaults)(page, {
      host: baseUrl
    }));
  }

}

exports.Snapshot = Snapshot;

_defineProperty(Snapshot, "description", 'Snapshot a list of pages from a file or directory');

_defineProperty(Snapshot, "args", [{
  name: 'pathname',
  description: 'path to a directory or file containing a list of pages',
  required: true
}]);

_defineProperty(Snapshot, "flags", { ..._cliCommand.flags.logging,
  ..._cliCommand.flags.discovery,
  ..._cliCommand.flags.config,
  'base-url': _cliCommand.flags.string({
    description: 'the base url pages are hosted at when snapshotting',
    char: 'b'
  }),
  'dry-run': _cliCommand.flags.boolean({
    description: 'prints a list of pages to snapshot without snapshotting',
    char: 'd'
  }),
  // static only flags
  files: _cliCommand.flags.string({
    description: 'one or more globs matching static file paths to snapshot',
    default: _config2.configSchema.static.properties.files.default,
    percyrc: 'static.files',
    multiple: true
  }),
  ignore: _cliCommand.flags.string({
    description: 'one or more globs matching static file paths to ignore',
    default: _config2.configSchema.static.properties.ignore.default,
    percyrc: 'static.ignore',
    multiple: true
  }),
  'clean-urls': _cliCommand.flags.boolean({
    description: 'rewrite static index and filepath URLs to be clean',
    percyrc: 'static.cleanUrls'
  })
});

_defineProperty(Snapshot, "examples", ['$ percy snapshot ./public', '$ percy snapshot pages.yml']);