"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = _interopRequireDefault(require("@percy/logger"));

var _utils = require("./utils");

var _discovery = require("./discovery");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

const NETWORK_TIMEOUT = 30000; // The Interceptor class creates common handlers for dealing with intercepting asset requests
// for a given page using various devtools protocol events and commands.

var _pending = /*#__PURE__*/new WeakMap();

var _requests = /*#__PURE__*/new WeakMap();

var _intercepts = /*#__PURE__*/new WeakMap();

var _authentications = /*#__PURE__*/new WeakMap();

var _frames = /*#__PURE__*/new WeakMap();

class Network {
  constructor(page) {
    _pending.set(this, {
      writable: true,
      value: new Map()
    });

    _requests.set(this, {
      writable: true,
      value: new Map()
    });

    _intercepts.set(this, {
      writable: true,
      value: new Map()
    });

    _authentications.set(this, {
      writable: true,
      value: new Set()
    });

    _frames.set(this, {
      writable: true,
      value: new Map()
    });

    _defineProperty(this, "log", (0, _logger.default)('core:network'));

    _defineProperty(this, "_handleAuthRequired", async event => {
      var _this$authorization;

      let {
        username,
        password
      } = (_this$authorization = this.authorization) !== null && _this$authorization !== void 0 ? _this$authorization : {};
      let {
        requestId
      } = event;
      let response = 'Default';

      if (_classPrivateFieldGet(this, _authentications).has(requestId)) {
        response = 'CancelAuth';
      } else if (username || password) {
        response = 'ProvideCredentials';

        _classPrivateFieldGet(this, _authentications).add(requestId);
      }

      await this.page.send('Fetch.continueWithAuth', {
        requestId: event.requestId,
        authChallengeResponse: {
          response,
          username,
          password
        }
      });
    });

    _defineProperty(this, "_handleRequestPaused", event => {
      let {
        networkId: requestId
      } = event;

      let pending = _classPrivateFieldGet(this, _pending).get(requestId);

      _classPrivateFieldGet(this, _pending).delete(requestId); // guard against redirects with the same requestId


      if ((pending === null || pending === void 0 ? void 0 : pending.request.url) === event.request.url && pending.request.method === event.request.method) {
        this._handleRequest(pending, event.requestId);
      } else {
        _classPrivateFieldGet(this, _intercepts).set(requestId, event);
      }
    });

    _defineProperty(this, "_handleRequestWillBeSent", event => {
      let {
        requestId,
        request
      } = event; // do not handle data urls

      if (request.url.startsWith('data:')) return;

      if (this._intercept) {
        let intercept = _classPrivateFieldGet(this, _intercepts).get(requestId);

        _classPrivateFieldGet(this, _pending).set(requestId, event);

        if (intercept) {
          this._handleRequest(event, intercept.requestId);

          _classPrivateFieldGet(this, _intercepts).delete(requestId);
        }
      } else {
        this._handleRequest(event);
      }
    });

    _defineProperty(this, "_handleRequest", async (event, interceptId) => {
      let {
        frameId,
        requestId,
        request
      } = event;
      let redirectChain = []; // if handling a redirected request, associate the response and add to its redirect chain

      if (event.redirectResponse && _classPrivateFieldGet(this, _requests).has(requestId)) {
        let req = _classPrivateFieldGet(this, _requests).get(requestId);

        redirectChain = [...req.redirectChain, req]; // clean up interim requests

        this._forgetRequest(req, true);
      }

      request.frameId = frameId;
      request.requestId = requestId;
      request.interceptId = interceptId;
      request.redirectChain = redirectChain;

      _classPrivateFieldGet(this, _requests).set(requestId, request);

      if (this._intercept) {
        await this.onrequest({ ...request,
          // call to continue the request as-is
          continue: () => this.page.send('Fetch.continueRequest', {
            requestId: interceptId
          }),
          // call to respond with a specific status, content, and headers
          respond: ({
            status,
            content,
            headers
          }) => this.page.send('Fetch.fulfillRequest', {
            requestId: interceptId,
            responseCode: status || 200,
            body: Buffer.from(content).toString('base64'),
            responseHeaders: Object.entries(headers || {}).map(([name, value]) => {
              return {
                name: name.toLowerCase(),
                value: String(value)
              };
            })
          }),
          // call to fail or abort the request
          abort: error => this.page.send('Fetch.failRequest', {
            requestId: interceptId,
            // istanbul note: this check used to be necessary and might be again in the future if we
            // ever need to abort a request due to reasons other than failures
            errorReason: error ? 'Failed' :
            /* istanbul ignore next */
            'Aborted'
          })
        });
      }
    });

    _defineProperty(this, "_handleResponseReceived", event => {
      let {
        requestId,
        response
      } = event;

      let request = _classPrivateFieldGet(this, _requests).get(requestId);
      /* istanbul ignore if: race condition paranioa */


      if (!request) return;
      request.response = response;

      request.response.buffer = async () => {
        let {
          body,
          base64Encoded
        } = await this.page.send('Network.getResponseBody', {
          requestId
        });
        return Buffer.from(body, base64Encoded ? 'base64' : 'utf8');
      };

      if (request.frameId !== this.page.frameId) {
        _classPrivateFieldGet(this, _frames).set(request.frameId, request);
      }
    });

    _defineProperty(this, "_handleEventSourceMessageReceived", event => {
      let request = _classPrivateFieldGet(this, _requests).get(event.requestId);
      /* istanbul ignore else: race condition paranioa */


      if (request) this._forgetRequest(request);
    });

    _defineProperty(this, "_handleLoadingFinished", async event => {
      let request = _classPrivateFieldGet(this, _requests).get(event.requestId);
      /* istanbul ignore if: race condition paranioa */


      if (!request) return;

      if (this._intercept) {
        await this.onrequestfinished(request);
      }

      this._forgetRequest(request);
    });

    _defineProperty(this, "_handleLoadingFailed", async event => {
      let request = _classPrivateFieldGet(this, _requests).get(event.requestId);
      /* istanbul ignore if: race condition paranioa */


      if (!request) return;

      if (this._intercept) {
        request.error = event.errorText;
        await this.onrequestfailed(request);
      }

      this._forgetRequest(request);
    });

    _defineProperty(this, "_handleFrameDetached", async event => {
      let request = _classPrivateFieldGet(this, _frames).get(event.frameId);
      /* istanbul ignore if: race condition paranioa */


      if (!request) return;
      /* istanbul ignore else: could be false when a page is used without asset discovery */

      if (this._intercept) {
        await this.onrequestfinished(request);
      }

      this._forgetRequest(request);
    });

    this.page = page;
    this.page.on('Fetch.authRequired', this._handleAuthRequired);
    this.page.on('Fetch.requestPaused', this._handleRequestPaused);
    this.page.on('Network.requestWillBeSent', this._handleRequestWillBeSent);
    this.page.on('Network.responseReceived', this._handleResponseReceived);
    this.page.on('Network.eventSourceMessageReceived', this._handleEventSourceMessageReceived);
    this.page.on('Network.loadingFinished', this._handleLoadingFinished);
    this.page.on('Network.loadingFailed', this._handleLoadingFailed);
    this.page.on('Page.frameDetached', this._handleFrameDetached);

    this.page._handleCloseRace(this.page.send('Network.enable'));
  } // Enable request interception


  async intercept(options) {
    this._intercept = true;
    this.onrequest = (0, _discovery.createRequestHandler)(options, this.page.meta);
    this.onrequestfinished = (0, _discovery.createRequestFinishedHandler)(options, this.page.meta);
    this.onrequestfailed = (0, _discovery.createRequestFailedHandler)(options, this.page.meta);
    await this.page.send('Fetch.enable', {
      handleAuthRequests: true,
      patterns: [{
        urlPattern: '*'
      }]
    });
  } // Resolves after the timeout when there are no more in-flight requests.


  async idle(filter, timeout = this.timeout || 100) {
    let requests = [];
    this.log.debug(`Wait for ${timeout}ms idle`, this.page.meta);
    await (0, _utils.waitFor)(() => {
      if (this.page.closedReason) {
        throw new Error(`Network error: ${this.page.closedReason}`);
      }

      requests = this.getRequests(filter);
      return requests.length === 0;
    }, {
      timeout: NETWORK_TIMEOUT,
      idle: timeout
    }).catch(error => {
      // throw a better timeout error
      if (error.message.startsWith('Timeout')) {
        let msg = 'Timed out waiting for network requests to idle.';

        if (this.log.shouldLog('debug')) {
          msg += `\n\n  ${['Active requests:', ...requests.map(r => r.url)].join('\n  -> ')}\n`;
        }

        throw new Error(msg);
      } else {
        throw error;
      }
    });
  } // Used to recursively collect requests from this frame and subframes


  getRequests(filter = () => true) {
    let requests = Array.from(_classPrivateFieldGet(this, _requests).values()).filter(filter);

    for (let frame of this.page.frames) {
      requests.push(...frame.network.getRequests(filter));
    }

    return requests;
  } // Called when a request should be removed from various trackers


  _forgetRequest({
    requestId,
    interceptId,
    frameId
  }, keepPending) {
    _classPrivateFieldGet(this, _requests).delete(requestId);

    _classPrivateFieldGet(this, _authentications).delete(interceptId);

    _classPrivateFieldGet(this, _frames).delete(frameId);

    if (!keepPending) {
      _classPrivateFieldGet(this, _pending).delete(requestId);

      _classPrivateFieldGet(this, _intercepts).delete(requestId);
    }
  } // Called when a request requires authentication. Responds to the auth request with any
  // provided authorization credentials.


}

exports.default = Network;